{{define "scripts"}}
<script>
// ===================== CONFIG =====================
const API = '/api/v1';
const MAP_STYLE = '{{.MapStyle}}';
const MAP_CENTER = [{{.MapCenter.Lon}}, {{.MapCenter.Lat}}];
const MAP_ZOOM = {{.MapZoom}};

// ===================== STATE =====================
let map = null;
let clickMarker = null;
let clickPoint = null;
let stationMarkers = [];
let poiMarkers = [];
let activePopup = null;

// Transport type colors
const TRANSPORT_COLORS = {
    metro: '#d32f2f', bus: '#388e3c', tram: '#f57c00',
    cercania: '#7b1fa2', long_distance: '#0288d1', train: '#0288d1'
};

// POI category colors
const POI_COLORS = {
    healthcare: '#e53935', shopping: '#ff9800', education: '#1976d2',
    leisure: '#43a047', food_drink: '#8d6e63'
};

// ===================== INIT =====================
async function initApp() {
    try {
        mapboxgl.accessToken = '{{.MapboxToken}}';
        if (!mapboxgl.accessToken) throw new Error('No Mapbox token configured');

        map = new mapboxgl.Map({
            container: 'map',
            style: MAP_STYLE,
            center: MAP_CENTER,
            zoom: MAP_ZOOM
        });

        map.addControl(new mapboxgl.NavigationControl(), 'top-right');
        map.addControl(new mapboxgl.ScaleControl({ unit: 'metric' }), 'bottom-right');

        map.on('mousemove', e => {
            document.getElementById('cursor-coords').textContent =
                `${e.lngLat.lat.toFixed(5)}, ${e.lngLat.lng.toFixed(5)}`;
        });

        map.on('zoom', () => {
            document.getElementById('zoom-level').textContent = `z${map.getZoom().toFixed(1)}`;
        });

        map.on('load', () => {
            addRadiusCircleSource();
            setupBoundaryTileLayer();
            setupEnvironmentTileLayers();
            setupTransportTileLayer();
            setupPOITileLayer();
            setupLayerInteractivity();
            // Load viewport data on initial load and on map move
            loadViewportData();
            setupDataSidebarScroll();
        });

        // Reload viewport data when map moves
        map.on('moveend', onViewportChanged);

        setupEventListeners();
    } catch (err) {
        console.error('Init error:', err);
        document.getElementById('click-results').innerHTML =
            `<div class="error-msg">–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏: ${err.message}</div>`;
    }
}

// ===================== TILE LAYERS =====================

function getSelectedTransportTypes() {
    return Array.from(document.querySelectorAll('[data-transport]:checked'))
        .map(cb => cb.dataset.transport);
}

function getSelectedPOICategories() {
    return Array.from(document.querySelectorAll('[data-poi]:checked'))
        .map(cb => cb.dataset.poi);
}

function getSelectedPOISubcategories() {
    return Array.from(document.querySelectorAll('[data-poi-sub]:checked'))
        .map(cb => cb.dataset.poiSub);
}

// --- Transport tiles ---
function setupTransportTileLayer() {
    const types = getSelectedTransportTypes();
    if (types.length === 0) return;

    const url = `${location.origin}${API}/tiles/transport/{z}/{x}/{y}.pbf?types=${types.join(',')}`;

    map.addSource('transport-tiles', {
        type: 'vector',
        tiles: [url],
        minzoom: 8,
        maxzoom: 16
    });

    // Station circles
    map.addLayer({
        id: 'transport-stations-circle',
        type: 'circle',
        source: 'transport-tiles',
        'source-layer': 'stations',
        paint: {
            'circle-radius': ['interpolate', ['linear'], ['zoom'], 10, 3, 14, 7, 16, 10],
            'circle-color': ['match', ['get', 'type'],
                'subway', TRANSPORT_COLORS.metro,
                'station', TRANSPORT_COLORS.train,
                'tram_stop', TRANSPORT_COLORS.tram,
                'bus_stop', TRANSPORT_COLORS.bus,
                'stop', TRANSPORT_COLORS.bus,
                '#888'
            ],
            'circle-stroke-width': 1.5,
            'circle-stroke-color': '#fff'
        }
    });

    // Station labels
    map.addLayer({
        id: 'transport-stations-label',
        type: 'symbol',
        source: 'transport-tiles',
        'source-layer': 'stations',
        minzoom: 13,
        layout: {
            'text-field': ['get', 'name'],
            'text-size': 11,
            'text-offset': [0, 1.3],
            'text-anchor': 'top',
            'text-max-width': 10,
            'text-allow-overlap': false
        },
        paint: {
            'text-color': '#e6edf3',
            'text-halo-color': '#0d1117',
            'text-halo-width': 1.5
        }
    });

    // Lines
    map.addLayer({
        id: 'transport-lines',
        type: 'line',
        source: 'transport-tiles',
        'source-layer': 'lines',
        paint: {
            'line-color': ['case',
                ['!=', ['get', 'color'], ''], ['get', 'color'],
                ['match', ['get', 'type'],
                    'subway', TRANSPORT_COLORS.metro,
                    'train', TRANSPORT_COLORS.train,
                    'tram', TRANSPORT_COLORS.tram,
                    'bus', TRANSPORT_COLORS.bus,
                    '#888'
                ]
            ],
            'line-width': ['interpolate', ['linear'], ['zoom'], 10, 1.5, 14, 3, 16, 4],
            'line-opacity': 0.7
        }
    }, 'transport-stations-circle');
}

function refreshTransportTiles() {
    const types = getSelectedTransportTypes();

    // Remove existing layers and source
    ['transport-stations-label', 'transport-stations-circle', 'transport-lines'].forEach(id => {
        if (map.getLayer(id)) map.removeLayer(id);
    });
    if (map.getSource('transport-tiles')) map.removeSource('transport-tiles');

    if (types.length > 0) {
        setupTransportTileLayer();
    }
}

// --- POI tiles ---
function setupPOITileLayer() {
    const cats = getSelectedPOICategories();
    const subs = getSelectedPOISubcategories();
    if (cats.length === 0 && subs.length === 0) return;

    let params = [];
    if (cats.length > 0) params.push(`categories=${cats.join(',')}`);
    if (subs.length > 0) params.push(`subcategories=${subs.join(',')}`);
    const qs = params.join('&');

    const url = `${location.origin}${API}/tiles/poi/{z}/{x}/{y}.pbf?${qs}`;

    map.addSource('poi-tiles', {
        type: 'vector',
        tiles: [url],
        minzoom: 12,
        maxzoom: 16
    });

    map.addLayer({
        id: 'poi-circles',
        type: 'circle',
        source: 'poi-tiles',
        'source-layer': 'pois',
        paint: {
            'circle-radius': ['interpolate', ['linear'], ['zoom'], 12, 2.5, 14, 5, 16, 8],
            'circle-color': ['match', ['get', 'category'],
                'healthcare', POI_COLORS.healthcare,
                'shopping', POI_COLORS.shopping,
                'education', POI_COLORS.education,
                'leisure', POI_COLORS.leisure,
                'food_drink', POI_COLORS.food_drink,
                '#888'
            ],
            'circle-stroke-width': 1,
            'circle-stroke-color': 'rgba(255,255,255,0.7)',
            'circle-opacity': 0.85
        }
    });

    map.addLayer({
        id: 'poi-labels',
        type: 'symbol',
        source: 'poi-tiles',
        'source-layer': 'pois',
        minzoom: 14,
        layout: {
            'text-field': ['get', 'name'],
            'text-size': 10,
            'text-offset': [0, 1.2],
            'text-anchor': 'top',
            'text-max-width': 8,
            'text-allow-overlap': false
        },
        paint: {
            'text-color': '#c9d1d9',
            'text-halo-color': '#0d1117',
            'text-halo-width': 1
        }
    });
}

function refreshPOITiles() {
    ['poi-labels', 'poi-circles'].forEach(id => {
        if (map.getLayer(id)) map.removeLayer(id);
    });
    if (map.getSource('poi-tiles')) map.removeSource('poi-tiles');

    setupPOITileLayer();
}

// --- Boundary tiles ---
function setupBoundaryTileLayer() {
    const url = `${location.origin}${API}/boundaries/tiles/{z}/{x}/{y}.pbf`;

    map.addSource('boundary-tiles', {
        type: 'vector',
        tiles: [url],
        minzoom: 4,
        maxzoom: 14
    });

    map.addLayer({
        id: 'boundary-fill',
        type: 'fill',
        source: 'boundary-tiles',
        'source-layer': 'boundaries',
        paint: {
            'fill-color': '#58a6ff',
            'fill-opacity': 0.04
        },
        layout: { 'visibility': 'none' }
    });

    map.addLayer({
        id: 'boundary-line',
        type: 'line',
        source: 'boundary-tiles',
        'source-layer': 'boundaries',
        paint: {
            'line-color': '#58a6ff',
            'line-width': ['interpolate', ['linear'], ['zoom'], 6, 0.5, 10, 1.5, 14, 2.5],
            'line-opacity': 0.6,
            'line-dasharray': [2, 2]
        },
        layout: { 'visibility': 'none' }
    });

    map.addLayer({
        id: 'boundary-label',
        type: 'symbol',
        source: 'boundary-tiles',
        'source-layer': 'boundaries',
        minzoom: 10,
        layout: {
            'text-field': ['get', 'name'],
            'text-size': 12,
            'text-max-width': 10,
            'text-allow-overlap': false,
            'visibility': 'none'
        },
        paint: {
            'text-color': '#58a6ff',
            'text-halo-color': '#0d1117',
            'text-halo-width': 1.5
        }
    });
}

function toggleBoundaryLayer(visible) {
    const vis = visible ? 'visible' : 'none';
    ['boundary-fill', 'boundary-line', 'boundary-label'].forEach(id => {
        if (map.getLayer(id)) map.setLayoutProperty(id, 'visibility', vis);
    });
}

// --- Environment tiles ---
function setupEnvironmentTileLayers() {
    // Green spaces
    map.addSource('green-tiles', {
        type: 'vector',
        tiles: [`${location.origin}${API}/green-spaces/tiles/{z}/{x}/{y}.pbf`],
        minzoom: 10, maxzoom: 16
    });
    map.addLayer({
        id: 'green-fill', type: 'fill', source: 'green-tiles', 'source-layer': 'green_spaces',
        paint: { 'fill-color': '#4caf50', 'fill-opacity': 0.25 },
        layout: { 'visibility': 'none' }
    });
    map.addLayer({
        id: 'green-outline', type: 'line', source: 'green-tiles', 'source-layer': 'green_spaces',
        paint: { 'line-color': '#4caf50', 'line-width': 1, 'line-opacity': 0.5 },
        layout: { 'visibility': 'none' }
    });

    // Water
    map.addSource('water-tiles', {
        type: 'vector',
        tiles: [`${location.origin}${API}/water/tiles/{z}/{x}/{y}.pbf`],
        minzoom: 10, maxzoom: 16
    });
    map.addLayer({
        id: 'water-fill', type: 'fill', source: 'water-tiles', 'source-layer': 'water',
        paint: { 'fill-color': '#2196f3', 'fill-opacity': 0.25 },
        layout: { 'visibility': 'none' }
    });
    map.addLayer({
        id: 'water-outline', type: 'line', source: 'water-tiles', 'source-layer': 'water',
        paint: { 'line-color': '#2196f3', 'line-width': 1, 'line-opacity': 0.5 },
        layout: { 'visibility': 'none' }
    });

    // Beaches
    map.addSource('beach-tiles', {
        type: 'vector',
        tiles: [`${location.origin}${API}/beaches/tiles/{z}/{x}/{y}.pbf`],
        minzoom: 12, maxzoom: 16
    });
    map.addLayer({
        id: 'beach-fill', type: 'fill', source: 'beach-tiles', 'source-layer': 'beaches',
        paint: { 'fill-color': '#fdd835', 'fill-opacity': 0.3 },
        layout: { 'visibility': 'none' }
    });
    map.addLayer({
        id: 'beach-outline', type: 'line', source: 'beach-tiles', 'source-layer': 'beaches',
        paint: { 'line-color': '#fdd835', 'line-width': 1.5, 'line-opacity': 0.6 },
        layout: { 'visibility': 'none' }
    });
}

function toggleEnvLayer(type, visible) {
    const vis = visible ? 'visible' : 'none';
    const layers = {
        green: ['green-fill', 'green-outline'],
        water: ['water-fill', 'water-outline'],
        beaches: ['beach-fill', 'beach-outline']
    };
    (layers[type] || []).forEach(id => {
        if (map.getLayer(id)) map.setLayoutProperty(id, 'visibility', vis);
    });
}

// ===================== LAYER INTERACTIVITY =====================
function setupLayerInteractivity() {
    // Transport station click
    map.on('click', (e) => {
        // Check transport stations first
        if (map.getLayer('transport-stations-circle')) {
            const stationFeatures = map.queryRenderedFeatures(e.point, { layers: ['transport-stations-circle'] });
            if (stationFeatures.length > 0) {
                const props = stationFeatures[0].properties;
                const html = `
                    <div class="popup-title">${props.name || '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è'}</div>
                    <div class="popup-type">${props.type || 'station'}</div>
                    <div class="popup-detail">ID: ${props.id}</div>
                `;
                if (activePopup) activePopup.remove();
                activePopup = new mapboxgl.Popup({ closeOnClick: true })
                    .setLngLat(e.lngLat)
                    .setHTML(html)
                    .addTo(map);
                return; // Don't process further
            }
        }

        // Check POI
        if (map.getLayer('poi-circles')) {
            const poiFeatures = map.queryRenderedFeatures(e.point, { layers: ['poi-circles'] });
            if (poiFeatures.length > 0) {
                const props = poiFeatures[0].properties;
                const html = `
                    <div class="popup-title">${props.name || '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è'}</div>
                    <div class="popup-type">${props.category} / ${props.subcategory}</div>
                    <div class="popup-detail">ID: ${props.id}</div>
                `;
                if (activePopup) activePopup.remove();
                activePopup = new mapboxgl.Popup({ closeOnClick: true })
                    .setLngLat(e.lngLat)
                    .setHTML(html)
                    .addTo(map);
                return;
            }
        }

        // Check boundaries
        if (map.getLayer('boundary-fill')) {
            const vis = map.getLayoutProperty('boundary-fill', 'visibility');
            if (vis === 'visible') {
                const bFeatures = map.queryRenderedFeatures(e.point, { layers: ['boundary-fill'] });
                if (bFeatures.length > 0) {
                    const props = bFeatures[0].properties;
                    const html = `
                        <div class="popup-title">${props.name || '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è'}</div>
                        <div class="popup-type">Admin level ${props.admin_level || '?'}</div>
                        ${props.population ? `<div class="popup-detail">–ù–∞—Å–µ–ª–µ–Ω–∏–µ: ${Number(props.population).toLocaleString()}</div>` : ''}
                    `;
                    if (activePopup) activePopup.remove();
                    activePopup = new mapboxgl.Popup({ closeOnClick: true })
                        .setLngLat(e.lngLat)
                        .setHTML(html)
                        .addTo(map);
                    return;
                }
            }
        }

        // No feature hit ‚Äî proceed with map click (load data by point)
        handleMapClick(e);
    });

    // Cursor style
    map.on('mousemove', (e) => {
        const interactiveLayers = ['transport-stations-circle', 'poi-circles'].filter(l => map.getLayer(l));
        if (interactiveLayers.length === 0) {
            map.getCanvas().style.cursor = '';
            return;
        }
        const features = map.queryRenderedFeatures(e.point, { layers: interactiveLayers });
        map.getCanvas().style.cursor = features.length > 0 ? 'pointer' : '';
    });
}

// ===================== RADIUS CIRCLE =====================
function addRadiusCircleSource() {
    map.addSource('radius-circle', {
        type: 'geojson',
        data: { type: 'FeatureCollection', features: [] }
    });

    map.addLayer({
        id: 'radius-circle-fill',
        type: 'fill',
        source: 'radius-circle',
        paint: { 'fill-color': '#58a6ff', 'fill-opacity': 0.08 }
    });

    map.addLayer({
        id: 'radius-circle-stroke',
        type: 'line',
        source: 'radius-circle',
        paint: { 'line-color': '#58a6ff', 'line-width': 1.5, 'line-opacity': 0.4, 'line-dasharray': [4, 3] }
    });
}

function drawRadiusCircle(lat, lng, radiusM) {
    const src = map.getSource('radius-circle');
    if (!src) return;
    src.setData({
        type: 'FeatureCollection',
        features: [createCircle([lng, lat], radiusM / 1000, 64)]
    });
}

function clearRadiusCircle() {
    const src = map.getSource('radius-circle');
    if (src) src.setData({ type: 'FeatureCollection', features: [] });
}

function createCircle(center, radiusKm, steps) {
    const coords = [];
    for (let i = 0; i <= steps; i++) {
        const angle = (i / steps) * 360;
        coords.push(destPoint(center, radiusKm, angle));
    }
    return { type: 'Feature', geometry: { type: 'Polygon', coordinates: [coords] } };
}

function destPoint(origin, distKm, bearing) {
    const R = 6371;
    const d = distKm / R;
    const b = bearing * Math.PI / 180;
    const lat1 = origin[1] * Math.PI / 180;
    const lon1 = origin[0] * Math.PI / 180;
    const lat2 = Math.asin(Math.sin(lat1) * Math.cos(d) + Math.cos(lat1) * Math.sin(d) * Math.cos(b));
    const lon2 = lon1 + Math.atan2(Math.sin(b) * Math.sin(d) * Math.cos(lat1), Math.cos(d) - Math.sin(lat1) * Math.sin(lat2));
    return [lon2 * 180 / Math.PI, lat2 * 180 / Math.PI];
}

// ===================== MAP CLICK =====================
function handleMapClick(e) {
    const { lat, lng } = e.lngLat;
    clickPoint = { lat, lng };

    // Place marker
    if (clickMarker) clickMarker.remove();
    const el = document.createElement('div');
    el.className = 'click-marker';
    clickMarker = new mapboxgl.Marker(el).setLngLat([lng, lat]).addTo(map);

    // Draw radius
    const radius = parseInt(document.getElementById('param-radius').value) || 1000;
    drawRadiusCircle(lat, lng, radius);

    // Load data
    loadClickData(lat, lng);
}

// ===================== LOAD DATA BY CLICK =====================
async function loadClickData(lat, lng) {
    const resultsEl = document.getElementById('click-results');
    resultsEl.innerHTML = '<div class="loading-inline"><div class="spinner"></div>–ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö...</div>';

    // Clear old markers
    clearResultMarkers();

    const radius = parseInt(document.getElementById('param-radius').value) || 1000;
    const limit = parseInt(document.getElementById('param-limit').value) || 10;
    const types = getSelectedTransportTypes();
    const cats = getSelectedPOICategories();
    const subs = getSelectedPOISubcategories();

    try {
        // Parallel requests
        const promises = [];

        // 1. Reverse geocode
        promises.push(
            fetch(`${API}/reverse-geocode`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ lat, lon: lng })
            }).then(r => r.json()).catch(() => null)
        );

        // 2. Nearest transport
        if (types.length > 0) {
            promises.push(
                fetch(`${API}/transport/nearest`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ lat, lon: lng, max_distance: radius, types, limit })
                }).then(r => r.json()).catch(() => null)
            );
        } else {
            promises.push(Promise.resolve(null));
        }

        // 3. POI by radius
        if (cats.length > 0 || subs.length > 0) {
            const poiBody = { lat, lon: lng, radius, limit: limit * 2 };
            if (cats.length > 0) poiBody.categories = cats;
            if (subs.length > 0) poiBody.subcategories = subs;
            promises.push(
                fetch(`${API}/radius/poi`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(poiBody)
                }).then(r => r.json()).catch(() => null)
            );
        } else {
            promises.push(Promise.resolve(null));
        }

        const [geocodeRes, transportRes, poiRes] = await Promise.all(promises);

        let html = '';

        // Geocode result
        if (geocodeRes && geocodeRes.data) {
            html += renderGeocodeResult(geocodeRes.data);
        }

        // Transport results
        if (transportRes && transportRes.data) {
            const stations = transportRes.data.stations || transportRes.data.transport || [];
            html += renderTransportResults(stations);
        }

        // POI results
        if (poiRes && poiRes.data) {
            const pois = poiRes.data.pois || poiRes.data.results || poiRes.data || [];
            if (Array.isArray(pois)) {
                html += renderPOIResults(pois);
            }
        }

        if (!html) {
            html = '<div class="hint">–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —ç—Ç–æ–π —Ç–æ—á–∫–∏</div>';
        }

        resultsEl.innerHTML = html;

        // Click handlers on result cards
        resultsEl.querySelectorAll('.result-card[data-lat]').forEach(card => {
            card.addEventListener('click', () => {
                const lt = parseFloat(card.dataset.lat);
                const ln = parseFloat(card.dataset.lon);
                map.flyTo({ center: [ln, lt], zoom: Math.max(map.getZoom(), 15), duration: 800 });
            });
        });

    } catch (err) {
        resultsEl.innerHTML = `<div class="error-msg">–û—à–∏–±–∫–∞: ${err.message}</div>`;
    }
}

function clearResultMarkers() {
    stationMarkers.forEach(m => m.remove());
    stationMarkers = [];
    poiMarkers.forEach(m => m.remove());
    poiMarkers = [];
}

// ===================== RENDER RESULTS =====================
function renderGeocodeResult(data) {
    // data can be boundaries array or nested object
    let boundaries = [];
    if (Array.isArray(data)) {
        boundaries = data;
    } else if (data.boundaries) {
        boundaries = data.boundaries;
    } else if (data.address || data.city || data.country) {
        // Single result
        return `
            <div class="result-section">
                <div class="result-section-title">üìç –ê–¥—Ä–µ—Å</div>
                <div class="geocode-result">
                    ${data.country ? `<div class="gr-row"><span class="gr-label">–°—Ç—Ä–∞–Ω–∞</span><span class="gr-value">${data.country}</span></div>` : ''}
                    ${data.region ? `<div class="gr-row"><span class="gr-label">–†–µ–≥–∏–æ–Ω</span><span class="gr-value">${data.region}</span></div>` : ''}
                    ${data.city ? `<div class="gr-row"><span class="gr-label">–ì–æ—Ä–æ–¥</span><span class="gr-value">${data.city}</span></div>` : ''}
                    ${data.district ? `<div class="gr-row"><span class="gr-label">–†–∞–π–æ–Ω</span><span class="gr-value">${data.district}</span></div>` : ''}
                    ${data.neighbourhood ? `<div class="gr-row"><span class="gr-label">Neighbourhood</span><span class="gr-value">${data.neighbourhood}</span></div>` : ''}
                </div>
            </div>`;
    }

    if (boundaries.length > 0) {
        let html = '<div class="result-section"><div class="result-section-title">üìç –ì—Ä–∞–Ω–∏—Ü—ã <span class="count">' + boundaries.length + '</span></div>';
        boundaries.forEach(b => {
            html += `<div class="geocode-result">
                <div class="gr-row"><span class="gr-label">–ù–∞–∑–≤–∞–Ω–∏–µ</span><span class="gr-value">${b.name || b.local_name || '-'}</span></div>
                <div class="gr-row"><span class="gr-label">Level</span><span class="gr-value">${b.admin_level || '-'}</span></div>
                ${b.name_en ? `<div class="gr-row"><span class="gr-label">EN</span><span class="gr-value">${b.name_en}</span></div>` : ''}
            </div>`;
        });
        html += '</div>';
        return html;
    }

    return '';
}

function renderTransportResults(stations) {
    if (!stations || stations.length === 0) return '';

    let html = `<div class="result-section">
        <div class="result-section-title">üöá –¢—Ä–∞–Ω—Å–ø–æ—Ä—Ç <span class="count">${stations.length}</span></div>`;

    stations.forEach(s => {
        const type = s.type || 'station';
        const dist = s.linear_distance || s.distance || 0;
        const walkDist = s.walking_distance || Math.round(dist * 1.3);
        const walkTime = s.walking_time || (walkDist / 83);

        // Add marker
        const el = document.createElement('div');
        el.className = `station-dot ${type}`;
        const marker = new mapboxgl.Marker(el).setLngLat([s.lon, s.lat]).addTo(map);
        stationMarkers.push(marker);

        let linesHtml = '';
        if (s.lines && s.lines.length > 0) {
            linesHtml = '<div class="rc-lines">';
            s.lines.forEach(l => {
                const bg = l.color || TRANSPORT_COLORS[type] || '#30363d';
                linesHtml += `<span class="line-badge" style="background:${bg}">${l.ref || l.name || l.type || ''}</span>`;
            });
            linesHtml += '</div>';
        }

        html += `
            <div class="result-card ${type}" data-lat="${s.lat}" data-lon="${s.lon}">
                <div class="rc-name">${s.name || '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è'}</div>
                <div class="rc-meta">
                    <span class="type-badge ${type}">${type}</span>
                    <span>üìè ${Math.round(dist)}–º</span>
                    <span>üö∂ ${Math.round(walkDist)}–º</span>
                    <span>‚è±Ô∏è ${walkTime.toFixed(1)}–º–∏–Ω</span>
                </div>
                ${linesHtml}
            </div>`;
    });

    html += '</div>';
    return html;
}

function renderPOIResults(pois) {
    if (!pois || pois.length === 0) return '';

    let html = `<div class="result-section">
        <div class="result-section-title">üìå POI <span class="count">${pois.length}</span></div>`;

    pois.forEach(p => {
        const cat = p.category || '';
        const sub = p.subcategory || '';
        const dist = p.distance || 0;

        // Add marker
        if (p.lon && p.lat) {
            const el = document.createElement('div');
            el.className = `poi-dot ${cat}`;
            const marker = new mapboxgl.Marker(el).setLngLat([p.lon, p.lat]).addTo(map);
            poiMarkers.push(marker);
        }

        html += `
            <div class="result-card ${cat}" data-lat="${p.lat || ''}" data-lon="${p.lon || ''}">
                <div class="rc-name">${p.name || '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è'}</div>
                <div class="rc-meta">
                    <span class="type-badge" style="background:${hexAlpha(POI_COLORS[cat] || '#888', 0.2)};color:${POI_COLORS[cat] || '#888'}">${sub || cat}</span>
                    ${dist ? `<span>üìè ${Math.round(dist)}–º</span>` : ''}
                </div>
            </div>`;
    });

    html += '</div>';
    return html;
}

function hexAlpha(hex, alpha) {
    const r = parseInt(hex.slice(1,3), 16);
    const g = parseInt(hex.slice(3,5), 16);
    const b = parseInt(hex.slice(5,7), 16);
    return `rgba(${r},${g},${b},${alpha})`;
}

// ===================== SEARCH =====================
async function doSearch() {
    const q = document.getElementById('search-input').value.trim();
    if (!q) return;

    const resultsEl = document.getElementById('search-results');
    resultsEl.innerHTML = '<div class="loading-inline"><div class="spinner"></div>–ü–æ–∏—Å–∫...</div>';

    try {
        const resp = await fetch(`${API}/search?q=${encodeURIComponent(q)}&language=en&limit=15`);
        const data = await resp.json();

        const items = data.data?.boundaries || data.data || [];

        if (!items.length) {
            resultsEl.innerHTML = '<div class="hint">–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ</div>';
            return;
        }

        let html = '';
        items.forEach(item => {
            const name = item.name || item.local_name || item.name_en || '-';
            const level = item.admin_level ? `Level ${item.admin_level}` : '';
            const pop = item.population ? `Pop: ${Number(item.population).toLocaleString()}` : '';
            const info = [level, pop, item.name_en].filter(Boolean).join(' ¬∑ ');

            html += `<div class="search-result-item" data-id="${item.osm_id || item.id || ''}" 
                          data-lat="${item.lat || item.center_lat || ''}" 
                          data-lon="${item.lon || item.center_lon || ''}">
                <div class="sr-name">${name}</div>
                ${info ? `<div class="sr-info">${info}</div>` : ''}
            </div>`;
        });

        resultsEl.innerHTML = html;

        resultsEl.querySelectorAll('.search-result-item').forEach(el => {
            el.addEventListener('click', () => {
                const lat = parseFloat(el.dataset.lat);
                const lon = parseFloat(el.dataset.lon);
                const id = el.dataset.id;

                if (lat && lon) {
                    map.flyTo({ center: [lon, lat], zoom: 13, duration: 1000 });
                }

                // Try to load boundary by ID and zoom to bbox
                if (id) {
                    fetch(`${API}/boundaries/${id}`)
                        .then(r => r.json())
                        .then(resp => {
                            const b = resp.data;
                            if (b && b.bbox) {
                                map.fitBounds([[b.bbox[0], b.bbox[1]], [b.bbox[2], b.bbox[3]]], { padding: 40 });
                            }
                        })
                        .catch(() => {});
                }
            });
        });

    } catch (err) {
        resultsEl.innerHTML = `<div class="error-msg">–û—à–∏–±–∫–∞: ${err.message}</div>`;
    }
}

// ===================== EVENT LISTENERS =====================
function setupEventListeners() {
    // Search
    document.getElementById('search-btn').addEventListener('click', doSearch);
    document.getElementById('search-input').addEventListener('keydown', e => {
        if (e.key === 'Enter') doSearch();
    });

    // Boundary layer toggle
    document.getElementById('layer-boundaries').addEventListener('change', e => {
        toggleBoundaryLayer(e.target.checked);
    });

    // Transport type toggles
    document.querySelectorAll('[data-transport]').forEach(cb => {
        cb.addEventListener('change', () => {
            refreshTransportTiles();
            onViewportChanged(); // reload sidebar data
        });
    });

    // POI category toggles ‚Äî check/uncheck all subcategories and refresh POI tiles
    document.querySelectorAll('[data-poi]').forEach(cb => {
        cb.addEventListener('change', () => {
            const cat = cb.dataset.poi;
            const subList = document.querySelector(`.subcategory-list[data-parent="${cat}"]`);
            if (subList) {
                subList.classList.toggle('open', cb.checked);
                subList.querySelectorAll('input[data-poi-sub]').forEach(sub => {
                    sub.checked = cb.checked;
                });
            }
            refreshPOITiles();
            onViewportChanged(); // reload sidebar data
        });
    });

    // POI subcategory toggles
    document.querySelectorAll('[data-poi-sub]').forEach(cb => {
        cb.addEventListener('change', () => {
            // Update parent checkbox state
            const cat = cb.dataset.cat;
            const parentCb = document.querySelector(`[data-poi="${cat}"]`);
            const allSubs = document.querySelectorAll(`[data-poi-sub][data-cat="${cat}"]`);
            const checkedSubs = document.querySelectorAll(`[data-poi-sub][data-cat="${cat}"]:checked`);
            if (parentCb) {
                parentCb.checked = checkedSubs.length > 0;
                parentCb.indeterminate = checkedSubs.length > 0 && checkedSubs.length < allSubs.length;
            }
            refreshPOITiles();
            onViewportChanged(); // reload sidebar data
        });
    });

    // Environment layer toggles
    document.querySelectorAll('[data-env]').forEach(cb => {
        cb.addEventListener('change', () => {
            toggleEnvLayer(cb.dataset.env, cb.checked);
        });
    });

    // Radius change -> redraw circle
    document.getElementById('param-radius').addEventListener('input', () => {
        if (clickPoint) {
            const radius = parseInt(document.getElementById('param-radius').value) || 1000;
            drawRadiusCircle(clickPoint.lat, clickPoint.lng, radius);
        }
    });

    // Data sidebar toggle
    document.getElementById('ds-toggle-btn').addEventListener('click', () => {
        const sidebar = document.getElementById('data-sidebar');
        const btn = document.getElementById('ds-toggle-btn');
        sidebar.classList.toggle('collapsed');
        btn.textContent = sidebar.classList.contains('collapsed') ? '‚ñ∂' : '‚óÄ';
        // Trigger map resize after transition
        setTimeout(() => map.resize(), 250);
    });
}

// ===================== PANEL TOGGLE =====================
function togglePanel(panelId) {
    document.getElementById(panelId).classList.toggle('collapsed');
}

// ===================== DATA SIDEBAR (VIEWPORT) =====================
let dsTransportOffset = 0;
let dsTransportTotal = 0;
let dsTransportLoading = false;
let dsPOIOffset = 0;
let dsPOITotal = 0;
let dsPOILoading = false;
const DS_PAGE_SIZE = 30;
let dsViewportDebounce = null;

function toggleDSSection(sectionId) {
    document.getElementById(sectionId).classList.toggle('collapsed');
}

function getViewportBBox() {
    const bounds = map.getBounds();
    return {
        sw_lat: bounds.getSouthWest().lat,
        sw_lon: bounds.getSouthWest().lng,
        ne_lat: bounds.getNorthEast().lat,
        ne_lon: bounds.getNorthEast().lng
    };
}

// Called when map moves
function onViewportChanged() {
    if (dsViewportDebounce) clearTimeout(dsViewportDebounce);
    dsViewportDebounce = setTimeout(() => {
        loadViewportData();
    }, 400);
}

async function loadViewportData() {
    // Reset pagination
    dsTransportOffset = 0;
    dsTransportTotal = 0;
    dsPOIOffset = 0;
    dsPOITotal = 0;
    document.getElementById('ds-transport-list').innerHTML = '';
    document.getElementById('ds-poi-list').innerHTML = '';

    await Promise.all([
        loadViewportTransport(false),
        loadViewportPOI(false)
    ]);
}

async function loadViewportTransport(append) {
    if (dsTransportLoading) return;
    dsTransportLoading = true;

    const loadingEl = document.getElementById('ds-transport-loading');
    const loadMoreEl = document.getElementById('ds-transport-load-more');
    loadingEl.style.display = 'flex';
    loadMoreEl.style.display = 'none';

    const bbox = getViewportBBox();
    const types = getSelectedTransportTypes();
    const params = new URLSearchParams({
        sw_lat: bbox.sw_lat, sw_lon: bbox.sw_lon,
        ne_lat: bbox.ne_lat, ne_lon: bbox.ne_lon,
        limit: DS_PAGE_SIZE, offset: dsTransportOffset
    });
    if (types.length > 0) params.set('types', types.join(','));

    try {
        const resp = await fetch(`${API}/viewport/transport?${params}`);
        const data = await resp.json();

        if (data.data) {
            const stations = data.data.stations || [];
            dsTransportTotal = data.data.total || 0;
            dsTransportOffset += stations.length;

            const countEl = document.getElementById('ds-transport-count');
            countEl.textContent = dsTransportTotal;

            const listEl = document.getElementById('ds-transport-list');
            if (!append) listEl.innerHTML = '';

            stations.forEach(s => {
                listEl.insertAdjacentHTML('beforeend', renderDSTransportCard(s));
            });

            // Show load more if there are more results
            if (dsTransportOffset < dsTransportTotal) {
                loadMoreEl.style.display = 'block';
            }

            // Click handlers for cards
            listEl.querySelectorAll('.ds-card[data-lat]:not([data-bound])').forEach(card => {
                card.setAttribute('data-bound', '1');
                card.addEventListener('click', () => {
                    const lt = parseFloat(card.dataset.lat);
                    const ln = parseFloat(card.dataset.lon);
                    if (lt && ln) {
                        map.flyTo({ center: [ln, lt], zoom: Math.max(map.getZoom(), 15), duration: 800 });
                    }
                });
            });
        }
    } catch (err) {
        console.error('Viewport transport error:', err);
    } finally {
        loadingEl.style.display = 'none';
        dsTransportLoading = false;
    }
}

async function loadViewportPOI(append) {
    if (dsPOILoading) return;
    dsPOILoading = true;

    const loadingEl = document.getElementById('ds-poi-loading');
    const loadMoreEl = document.getElementById('ds-poi-load-more');
    loadingEl.style.display = 'flex';
    loadMoreEl.style.display = 'none';

    const bbox = getViewportBBox();
    const cats = getSelectedPOICategories();
    const subs = getSelectedPOISubcategories();
    const params = new URLSearchParams({
        sw_lat: bbox.sw_lat, sw_lon: bbox.sw_lon,
        ne_lat: bbox.ne_lat, ne_lon: bbox.ne_lon,
        limit: DS_PAGE_SIZE, offset: dsPOIOffset
    });
    if (cats.length > 0) params.set('categories', cats.join(','));
    if (subs.length > 0) params.set('subcategories', subs.join(','));

    try {
        const resp = await fetch(`${API}/viewport/poi?${params}`);
        const data = await resp.json();

        if (data.data) {
            const pois = data.data.pois || [];
            dsPOITotal = data.data.total || 0;
            dsPOIOffset += pois.length;

            const countEl = document.getElementById('ds-poi-count');
            countEl.textContent = dsPOITotal;

            const listEl = document.getElementById('ds-poi-list');
            if (!append) listEl.innerHTML = '';

            pois.forEach(p => {
                listEl.insertAdjacentHTML('beforeend', renderDSPOICard(p));
            });

            if (dsPOIOffset < dsPOITotal) {
                loadMoreEl.style.display = 'block';
            }

            listEl.querySelectorAll('.ds-card[data-lat]:not([data-bound])').forEach(card => {
                card.setAttribute('data-bound', '1');
                card.addEventListener('click', () => {
                    const lt = parseFloat(card.dataset.lat);
                    const ln = parseFloat(card.dataset.lon);
                    if (lt && ln) {
                        map.flyTo({ center: [ln, lt], zoom: Math.max(map.getZoom(), 15), duration: 800 });
                    }
                });
            });
        }
    } catch (err) {
        console.error('Viewport POI error:', err);
    } finally {
        loadingEl.style.display = 'none';
        dsPOILoading = false;
    }
}

function loadMoreTransport() {
    loadViewportTransport(true);
}

function loadMorePOI() {
    loadViewportPOI(true);
}

function renderDSTransportCard(s) {
    const type = s.type || 'station';
    let linesHtml = '';
    if (s.lines && s.lines.length > 0) {
        linesHtml = '<div class="ds-card-lines">';
        s.lines.forEach(l => {
            const bg = l.color || TRANSPORT_COLORS[type] || '#30363d';
            const label = l.ref || l.name || l.type || '';
            linesHtml += `<span class="line-badge" style="background:${bg}">${label}</span>`;
        });
        linesHtml += '</div>';
    }

    return `<div class="ds-card ${type}" data-lat="${s.lat || ''}" data-lon="${s.lon || ''}">
        <div class="ds-card-name">
            <span class="type-badge ${type}">${type}</span>
            ${s.name || '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è'}
        </div>
        ${s.name_en && s.name_en !== s.name ? `<div class="ds-card-meta"><span>${s.name_en}</span></div>` : ''}
        ${linesHtml}
    </div>`;
}

function renderDSPOICard(p) {
    const cat = p.category || '';
    const sub = p.subcategory || '';

    let details = '';
    if (p.address) details += `<div class="ds-card-detail"><span class="dl">üìç</span> <span class="dv">${p.address}</span></div>`;
    if (p.phone) details += `<div class="ds-card-detail"><span class="dl">üìû</span> <span class="dv">${p.phone}</span></div>`;
    if (p.website) details += `<div class="ds-card-detail"><span class="dl">üåê</span> <span class="dv"><a href="${p.website}" target="_blank" style="color:#58a6ff;text-decoration:none">${truncate(p.website,40)}</a></span></div>`;
    if (p.opening_hours) details += `<div class="ds-card-detail"><span class="dl">üïê</span> <span class="dv">${p.opening_hours}</span></div>`;
    if (p.cuisine) details += `<div class="ds-card-detail"><span class="dl">üçΩÔ∏è</span> <span class="dv">${p.cuisine}</span></div>`;
    if (p.wheelchair !== undefined && p.wheelchair !== null) details += `<div class="ds-card-detail"><span class="dl">‚ôø</span> <span class="dv">${p.wheelchair ? '–î–∞' : '–ù–µ—Ç'}</span></div>`;
    if (p.brand) details += `<div class="ds-card-detail"><span class="dl">üè∑Ô∏è</span> <span class="dv">${p.brand}</span></div>`;
    if (p.operator) details += `<div class="ds-card-detail"><span class="dl">üè¢</span> <span class="dv">${p.operator}</span></div>`;

    let starsHtml = '';
    if (p.stars && p.stars > 0) {
        starsHtml = `<div class="ds-card-stars">${'‚≠ê'.repeat(Math.min(p.stars, 5))}</div>`;
    }

    return `<div class="ds-card ${cat}" data-lat="${p.lat || ''}" data-lon="${p.lon || ''}">
        <div class="ds-card-name">
            <span class="type-badge" style="background:${hexAlpha(POI_COLORS[cat] || '#888', 0.2)};color:${POI_COLORS[cat] || '#888'}">${sub || cat}</span>
            ${p.name || '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è'}
        </div>
        ${p.name_en && p.name_en !== p.name ? `<div class="ds-card-meta"><span>${p.name_en}</span></div>` : ''}
        ${starsHtml}
        ${details}
    </div>`;
}

function truncate(str, max) {
    if (!str) return '';
    return str.length > max ? str.substring(0, max) + '‚Ä¶' : str;
}

// Setup infinite scroll on the data sidebar
function setupDataSidebarScroll() {
    const sidebar = document.getElementById('data-sidebar');
    sidebar.addEventListener('scroll', () => {
        const { scrollTop, scrollHeight, clientHeight } = sidebar;
        if (scrollTop + clientHeight >= scrollHeight - 100) {
            // Near bottom - load more if available
            if (dsTransportOffset < dsTransportTotal && !dsTransportLoading) {
                loadViewportTransport(true);
            }
            if (dsPOIOffset < dsPOITotal && !dsPOILoading) {
                loadViewportPOI(true);
            }
        }
    });
}

// ===================== START =====================
document.addEventListener('DOMContentLoaded', initApp);
</script>
{{end}}
