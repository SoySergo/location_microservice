{{define "scripts"}}
<script>
    // ========== Configuration ==========
    const API_BASE = '/api/v1';

    // ========== State ==========
    let map = null;
    let currentMethod = '{{.DefaultMethod}}';
    let searchPoints = [];
    let searchMarkers = [];
    let stationMarkers = [];
    let activePopup = null;
    let results = null;
    let rawResponse = null;
    let currentView = 'ui';

    // ========== Methods Configuration ==========
    const METHODS = {
        {{range .Methods}}
        '{{.ID}}': {
            name: '{{.Name}}',
            endpoint: '{{.Endpoint}}',
            httpMethod: '{{.HTTPMethod}}',
            isBatch: {{.IsBatch}},
            showTypes: {{.ShowTypes}}
        },
        {{end}}
    };

    // ========== Request Examples ==========
    const requestExamples = {
        // Search & Geocoding
        'search': { params: { q: 'Barcelona', language: 'en', limit: 10 } },
        'reverse-geocode': { body: { lat: 41.3851, lon: 2.1734 } },
        'reverse-geocode-batch': { body: { points: [{ lat: 41.3851, lon: 2.1734 }, { lat: 41.4036, lon: 2.1744 }] } },
        'boundary-by-id': { pathParams: { id: '1' } },
        
        // Location Enrichment
        'enrich-location': { 
            body: { 
                country: 'Spain',
                city: 'Barcelona',
                district: 'Eixample',
                latitude: 41.3851,
                longitude: 2.1734,
                is_visible: true
            } 
        },
        'enrich-location-batch': {
            body: {
                locations: [
                    { index: 0, country: 'Spain', city: 'Barcelona', latitude: 41.3851, longitude: 2.1734, is_visible: true },
                    { index: 1, country: 'Spain', city: 'Madrid', latitude: 40.4168, longitude: -3.7038, is_visible: true }
                ]
            }
        },
        'detect-location-batch': {
            body: {
                locations: [
                    { index: 0, country: 'Spain', city: 'Barcelona' },
                    { index: 1, country: 'Spain', region: 'Catalonia', city: 'Girona' }
                ]
            }
        },
        
        // Transport
        'transport-nearest': { body: { lat: 41.3851, lon: 2.1734, max_distance: 1000, types: ['metro', 'bus'] } },
        'transport-nearest-batch': { body: { points: [{ lat: 41.3851, lon: 2.1734 }], max_distance: 1000, types: ['metro'] } },
        'transport-priority': { params: { lat: 41.3851, lon: 2.1734, radius: 1500, limit: 5 } },
        'transport-priority-batch': { body: { points: [{ lat: 41.3851, lon: 2.1734 }], radius: 1500, limit: 5 } },
        'station-lines': { pathParams: { station_id: '1' } },
        
        // POI
        'poi-radius': { body: { lat: 41.3851, lon: 2.1734, radius: 500, categories: ['healthcare', 'shopping'] } },
        'poi-categories': { params: { language: 'en' } },
        'poi-subcategories': { pathParams: { id: 'healthcare' } },
        
        // Tiles (no examples needed for tiles as they require specific z/x/y coordinates)
        'tile-boundaries': { pathParams: { z: 13, x: 4096, y: 3073 } },
        'tile-transport': { pathParams: { z: 13, x: 4096, y: 3073 } },
        'tile-transport-filtered': { pathParams: { z: 13, x: 4096, y: 3073 } },
        'tile-poi': { pathParams: { z: 13, x: 4096, y: 3073 } },
        'tile-green-spaces': { pathParams: { z: 13, x: 4096, y: 3073 } },
        'tile-water': { pathParams: { z: 13, x: 4096, y: 3073 } },
        'tile-beaches': { pathParams: { z: 13, x: 4096, y: 3073 } },
        
        // System
        'stats': {},
        'health': {}
    };

    // ========== DOM Elements ==========
    const resultsContainer = document.getElementById('results-container');
    const uiResults = document.getElementById('ui-results');
    const jsonResults = document.getElementById('json-results');
    const pointsCountSpan = document.getElementById('points-count');
    const executeBtn = document.getElementById('execute-btn');
    const clearBtn = document.getElementById('clear-btn');
    const typesGroup = document.getElementById('types-group');

    // ========== View Switching ==========
    function switchView(view) {
        currentView = view;
        document.getElementById('btn-view-ui').classList.toggle('active', view === 'ui');
        document.getElementById('btn-view-json').classList.toggle('active', view === 'json');
        
        uiResults.classList.toggle('hidden', view !== 'ui');
        jsonResults.classList.toggle('active', view === 'json');
    }

    // ========== JSON Syntax Highlighting ==========
    function syntaxHighlight(json) {
        if (typeof json !== 'string') {
            json = JSON.stringify(json, null, 2);
        }
        json = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function (match) {
            let cls = 'json-number';
            if (/^"/.test(match)) {
                if (/:$/.test(match)) {
                    cls = 'json-key';
                } else {
                    cls = 'json-string';
                }
            } else if (/true|false/.test(match)) {
                cls = 'json-boolean';
            } else if (/null/.test(match)) {
                cls = 'json-null';
            }
            return '<span class="' + cls + '">' + match + '</span>';
        });
    }

    function renderJson() {
        if (!rawResponse) {
            jsonResults.innerHTML = '<div class="instructions">–í—ã–ø–æ–ª–Ω–∏—Ç–µ –∑–∞–ø—Ä–æ—Å, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å JSON –æ—Ç–≤–µ—Ç</div>';
            return;
        }
        
        const highlighted = syntaxHighlight(rawResponse);
        jsonResults.innerHTML = `
            <div class="json-container">
                <button class="copy-json-btn" onclick="copyJson()">üìã –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
                <pre>${highlighted}</pre>
            </div>
        `;
    }

    function copyJson() {
        if (!rawResponse) return;
        
        const text = JSON.stringify(rawResponse, null, 2);
        navigator.clipboard.writeText(text).then(() => {
            const btn = document.querySelector('.copy-json-btn');
            btn.classList.add('copied');
            btn.textContent = '‚úì –°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ';
            setTimeout(() => {
                btn.classList.remove('copied');
                btn.textContent = 'üìã –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å';
            }, 2000);
        });
    }

    // ========== Initialize App ==========
    async function initApp() {
        try {
            const configResponse = await fetch(`${API_BASE}/debug/config/mapbox`);
            const config = await configResponse.json();

            if (!config.token) {
                throw new Error('Mapbox token not configured');
            }

            mapboxgl.accessToken = config.token;

            map = new mapboxgl.Map({
                container: 'map',
                style: '{{.MapStyle}}',
                center: [{{.MapCenter.Lon}}, {{.MapCenter.Lat}}],
                zoom: {{.MapZoom}}
            });

            map.addControl(new mapboxgl.NavigationControl(), 'top-right');
            map.on('click', handleMapClick);

            map.on('load', () => {
                map.addSource('radius-circles', {
                    type: 'geojson',
                    data: { type: 'FeatureCollection', features: [] }
                });

                map.addLayer({
                    id: 'radius-circles-fill',
                    type: 'fill',
                    source: 'radius-circles',
                    paint: {
                        'fill-color': '#00d4ff',
                        'fill-opacity': 0.1
                    }
                });

                map.addLayer({
                    id: 'radius-circles-stroke',
                    type: 'line',
                    source: 'radius-circles',
                    paint: {
                        'line-color': '#00d4ff',
                        'line-width': 2,
                        'line-opacity': 0.5
                    }
                });
            });

            setupEventListeners();

        } catch (error) {
            console.error('Failed to initialize:', error);
            uiResults.innerHTML = `
                <div class="no-results" style="color: #ff6b6b;">
                    –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏: ${error.message}
                </div>
            `;
        }
    }

    // ========== Event Listeners ==========
    function setupEventListeners() {
        document.querySelectorAll('.method-card').forEach(card => {
            card.addEventListener('click', () => {
                document.querySelectorAll('.method-card').forEach(c => c.classList.remove('active'));
                card.classList.add('active');
                currentMethod = card.dataset.method;
                updateUI();
            });
        });

        executeBtn.addEventListener('click', executeRequest);
        clearBtn.addEventListener('click', clearAll);
        document.getElementById('param-radius').addEventListener('input', updateRadiusCircles);
    }

    // ========== UI Updates ==========
    function updateUI() {
        const method = METHODS[currentMethod];
        typesGroup.style.display = method.showTypes ? 'block' : 'none';
        
        // –ú–µ—Ç–æ–¥—ã, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ —Ç—Ä–µ–±—É—é—Ç —Ç–æ—á–µ–∫ –Ω–∞ –∫–∞—Ä—Ç–µ
        const noPointsMethods = ['search', 'poi-categories', 'stats', 'health'];
        const needsPoints = !noPointsMethods.includes(currentMethod) && !currentMethod.startsWith('tile-');
        
        if (needsPoints) {
            const minPoints = method.isBatch ? 1 : 1;
            executeBtn.disabled = searchPoints.length < minPoints;
        } else {
            executeBtn.disabled = false;
        }
        
        pointsCountSpan.textContent = searchPoints.length;
    }

    // ========== Map Handlers ==========
    function handleMapClick(e) {
        const method = METHODS[currentMethod];
        const { lng, lat } = e.lngLat;

        if (!method.isBatch) {
            clearSearchPoints();
        }

        addSearchPoint(lat, lng);
        updateUI();
    }

    function addSearchPoint(lat, lng) {
        const method = METHODS[currentMethod];

        const el = document.createElement('div');
        el.className = `search-marker${method.isBatch ? ' batch' : ''}`;

        const marker = new mapboxgl.Marker(el)
            .setLngLat([lng, lat])
            .addTo(map);

        searchPoints.push({ lat, lng });
        searchMarkers.push(marker);

        updateRadiusCircles();
    }

    function clearSearchPoints() {
        searchMarkers.forEach(m => m.remove());
        searchMarkers = [];
        searchPoints = [];
        updateRadiusCircles();
    }

    function clearStationMarkers() {
        stationMarkers.forEach(m => m.remove());
        stationMarkers = [];
        if (activePopup) {
            activePopup.remove();
            activePopup = null;
        }
    }

    function clearAll() {
        clearSearchPoints();
        clearStationMarkers();
        results = null;
        rawResponse = null;
        uiResults.innerHTML = `
            <div class="instructions">
                <strong>–ù–∞—á–∞–ª–æ —Ä–∞–±–æ—Ç—ã:</strong><br>
                1. –í—ã–±–µ—Ä–∏—Ç–µ –º–µ—Ç–æ–¥ —Å–ø—Ä–∞–≤–∞<br>
                2. –ö–ª–∏–∫–Ω–∏—Ç–µ –Ω–∞ –∫–∞—Ä—Ç—É –¥–ª—è –≤—ã–±–æ—Ä–∞ —Ç–æ—á–∫–∏(–µ–∫)<br>
                3. –ù–∞–∂–º–∏—Ç–µ "–í—ã–ø–æ–ª–Ω–∏—Ç—å" –¥–ª—è –∑–∞–ø—Ä–æ—Å–∞<br>
                4. –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ—è–≤—è—Ç—Å—è –∑–¥–µ—Å—å
            </div>
        `;
        jsonResults.innerHTML = '<div class="instructions">–í—ã–ø–æ–ª–Ω–∏—Ç–µ –∑–∞–ø—Ä–æ—Å, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å JSON –æ—Ç–≤–µ—Ç</div>';
        updateUI();
    }

    function updateRadiusCircles() {
        const radiusM = parseFloat(document.getElementById('param-radius').value) || 1500;

        const features = searchPoints.map((point, idx) => {
            return turf.circle([point.lng, point.lat], radiusM / 1000, {
                steps: 64,
                units: 'kilometers',
                properties: { index: idx }
            });
        });

        const source = map.getSource('radius-circles');
        if (source) {
            source.setData({
                type: 'FeatureCollection',
                features: features
            });
        }
    }

    // Simple turf.circle implementation
    const turf = {
        circle: function (center, radius, options) {
            const steps = options.steps || 64;
            const coords = [];
            for (let i = 0; i < steps; i++) {
                const angle = (i / steps) * 360;
                const point = this.destination(center, radius, angle);
                coords.push(point);
            }
            coords.push(coords[0]);
            return {
                type: 'Feature',
                properties: options.properties || {},
                geometry: {
                    type: 'Polygon',
                    coordinates: [coords]
                }
            };
        },
        destination: function (origin, distance, bearing) {
            const R = 6371;
            const d = distance / R;
            const brng = bearing * Math.PI / 180;
            const lat1 = origin[1] * Math.PI / 180;
            const lon1 = origin[0] * Math.PI / 180;

            const lat2 = Math.asin(
                Math.sin(lat1) * Math.cos(d) +
                Math.cos(lat1) * Math.sin(d) * Math.cos(brng)
            );
            const lon2 = lon1 + Math.atan2(
                Math.sin(brng) * Math.sin(d) * Math.cos(lat1),
                Math.cos(d) - Math.sin(lat1) * Math.sin(lat2)
            );

            return [lon2 * 180 / Math.PI, lat2 * 180 / Math.PI];
        }
    };

    // ========== API Requests ==========
    // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏—è URL —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏
    function buildUrl(endpoint, params, pathParams) {
        let url = endpoint;
        
        // –ó–∞–º–µ–Ω—è–µ–º path parameters
        if (pathParams) {
            Object.keys(pathParams).forEach(key => {
                url = url.replace(`{${key}}`, pathParams[key]);
            });
        }
        
        // –î–æ–±–∞–≤–ª—è–µ–º query parameters
        if (params && Object.keys(params).length > 0) {
            const searchParams = new URLSearchParams(params);
            url += '?' + searchParams.toString();
        }
        
        return url;
    }

    async function executeRequest() {
        const method = METHODS[currentMethod];

        uiResults.innerHTML = '<div class="loading">–ó–∞–≥—Ä—É–∑–∫–∞...</div>';
        clearStationMarkers();

        try {
            let response;
            const radius = parseFloat(document.getElementById('param-radius').value) || 1500;
            const limit = parseInt(document.getElementById('param-limit').value) || 5;
            const example = requestExamples[currentMethod] || {};

            // –î–ª—è –º–µ—Ç–æ–¥–æ–≤, –∏—Å–ø–æ–ª—å–∑—É—é—â–∏—Ö —Ç–æ—á–∫–∏ –Ω–∞ –∫–∞—Ä—Ç–µ
            if (searchPoints.length > 0) {
                if (method.httpMethod === 'GET') {
                    // GET –∑–∞–ø—Ä–æ—Å —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏
                    const point = searchPoints[0];
                    const params = {
                        lat: point.lat,
                        lon: point.lng,
                        radius: radius,
                        limit: limit,
                        ...example.params
                    };
                    
                    if (method.showTypes) {
                        const types = getSelectedTypes();
                        if (types.length > 0) {
                            params.types = types.join(',');
                        }
                    }
                    
                    const url = buildUrl(method.endpoint, params, example.pathParams);
                    response = await fetch(url);
                } else if (method.httpMethod === 'POST' && method.isBatch) {
                    // POST Batch –∑–∞–ø—Ä–æ—Å
                    const body = {
                        points: searchPoints.map(p => ({ lat: p.lat, lon: p.lng })),
                        radius: radius,
                        limit: limit,
                        ...example.body
                    };
                    
                    if (method.showTypes) {
                        const types = getSelectedTypes();
                        if (types.length > 0) {
                            body.types = types;
                        }
                    }
                    
                    response = await fetch(buildUrl(method.endpoint, null, example.pathParams), {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(body)
                    });
                } else if (method.httpMethod === 'POST') {
                    // POST Single –∑–∞–ø—Ä–æ—Å
                    const point = searchPoints[0];
                    const body = {
                        lat: point.lat,
                        lon: point.lng,
                        max_distance: radius,
                        radius: radius,
                        limit: limit,
                        ...example.body
                    };
                    
                    if (method.showTypes) {
                        const types = getSelectedTypes();
                        if (types.length > 0) {
                            body.types = types;
                        }
                    }
                    
                    response = await fetch(buildUrl(method.endpoint, null, example.pathParams), {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(body)
                    });
                }
            } else {
                // –ú–µ—Ç–æ–¥—ã –±–µ–∑ —Ç–æ—á–µ–∫ –Ω–∞ –∫–∞—Ä—Ç–µ (stats, health, categories, etc.)
                if (method.httpMethod === 'GET') {
                    const url = buildUrl(method.endpoint, example.params, example.pathParams);
                    response = await fetch(url);
                } else if (method.httpMethod === 'POST' && example.body) {
                    response = await fetch(buildUrl(method.endpoint, null, example.pathParams), {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(example.body)
                    });
                }
            }

            if (!response) {
                throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –≤—ã–ø–æ–ª–Ω–∏—Ç—å –∑–∞–ø—Ä–æ—Å. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã.');
            }

            // –î–ª—è —Ç–∞–π–ª–æ–≤ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è –±–∏–Ω–∞—Ä–Ω—ã–π –æ—Ç–≤–µ—Ç
            if (currentMethod.startsWith('tile-')) {
                const blob = await response.blob();
                rawResponse = { 
                    success: true, 
                    message: `–¢–∞–π–ª –ø–æ–ª—É—á–µ–Ω (${blob.size} –±–∞–π—Ç)`,
                    contentType: response.headers.get('Content-Type')
                };
                uiResults.innerHTML = `
                    <div class="meta-info">
                        <span>–†–∞–∑–º–µ—Ä: <strong class="highlight">${blob.size} –±–∞–π—Ç</strong></span>
                        <span>–¢–∏–ø: ${response.headers.get('Content-Type')}</span>
                    </div>
                    <div class="instructions">
                        –¢–∞–π–ª—ã –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –Ω–∞ –∫–∞—Ä—Ç–∞—Ö.<br>
                        Endpoint: <code>${method.endpoint}</code>
                    </div>
                `;
                renderJson();
                return;
            }

            rawResponse = await response.json();
            console.log('API Response:', rawResponse);

            if (rawResponse.success === false) {
                throw new Error(rawResponse.error?.message || 'Unknown error');
            }

            results = rawResponse.data || rawResponse;
            renderResults();
            renderJson();

        } catch (error) {
            console.error('Request failed:', error);
            uiResults.innerHTML = `
                <div class="no-results" style="color: #ff6b6b;">
                    –û—à–∏–±–∫–∞: ${error.message}
                </div>
            `;
            rawResponse = { error: error.message };
            renderJson();
        }
    }

    function getSelectedTypes() {
        const select = document.getElementById('param-types');
        return Array.from(select.selectedOptions).map(o => o.value);
    }

    // ========== Render Results ==========
    function renderResults() {
        const method = METHODS[currentMethod];

        if (!results) {
            uiResults.innerHTML = '<div class="no-results">–ù–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤</div>';
            return;
        }

        let html = '';

        if (method.isBatch) {
            html = renderBatchResults();
        } else {
            html = renderSingleResults();
        }

        uiResults.innerHTML = html;

        document.querySelectorAll('.station-item').forEach(item => {
            item.addEventListener('click', () => {
                const lat = parseFloat(item.dataset.lat);
                const lon = parseFloat(item.dataset.lon);
                map.flyTo({ center: [lon, lat], zoom: 16, duration: 1000 });
            });
        });
    }

    function renderSingleResults() {
        const stations = results.stations || results.transport || [];
        const meta = results.meta || {};

        let html = `
            <div class="meta-info">
                <span>–ù–∞–π–¥–µ–Ω–æ: <strong class="highlight">${meta.total_found || stations.length}</strong></span>
                <span>–†–∞–¥–∏—É—Å: ${meta.radius_m || '-'}–º</span>
                ${meta.priority_type ? `<span>–¢–∏–ø: <strong class="highlight">${meta.priority_type}</strong></span>` : ''}
            </div>
        `;

        if (stations.length === 0) {
            html += '<div class="no-results">–°—Ç–∞–Ω—Ü–∏–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –≤ —É–∫–∞–∑–∞–Ω–Ω–æ–º —Ä–∞–¥–∏—É—Å–µ</div>';
            return html;
        }

        html += '<div class="result-point">';
        html += '<div class="result-point-content">';

        stations.forEach((station, idx) => {
            html += renderStationCard(station, idx);
            addStationMarker(station);
        });

        html += '</div></div>';
        return html;
    }

    function renderBatchResults() {
        const batchResults = results.results || [];
        const meta = results.meta || {};

        let html = `
            <div class="meta-info">
                <span>–¢–æ—á–µ–∫: <strong class="highlight">${meta.total_points || batchResults.length}</strong></span>
                <span>–°—Ç–∞–Ω—Ü–∏–π: <strong class="highlight">${meta.total_stations || '-'}</strong></span>
                <span>–†–∞–¥–∏—É—Å: ${meta.radius_m || '-'}–º</span>
            </div>
        `;

        if (batchResults.length === 0) {
            html += '<div class="no-results">–ù–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤</div>';
            return html;
        }

        batchResults.forEach((pointResult, pointIdx) => {
            const searchPoint = pointResult.search_point || {};
            const stations = pointResult.stations || [];

            html += `
                <div class="result-point">
                    <div class="result-point-header">
                        <h4>–¢–æ—á–∫–∞ ${pointIdx + 1}</h4>
                        <span class="coords">${searchPoint.lat?.toFixed(5)}, ${searchPoint.lon?.toFixed(5)}</span>
                    </div>
                    <div class="result-point-content">
            `;

            if (stations.length === 0) {
                html += '<div class="no-results" style="padding: 10px;">–°—Ç–∞–Ω—Ü–∏–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã</div>';
            } else {
                stations.forEach((station, stationIdx) => {
                    html += renderStationCard(station, `${pointIdx}-${stationIdx}`);
                    addStationMarker(station);
                });
            }

            html += '</div></div>';
        });

        return html;
    }

    function renderStationCard(station, idx) {
        const type = station.type || 'station';
        const linearDist = station.linear_distance || station.distance || 0;
        const walkingDist = station.walking_distance || linearDist * 1.2;
        const walkingTime = station.walking_time || (walkingDist / 83.3);

        let linesHtml = '';
        if (station.lines && station.lines.length > 0) {
            linesHtml = '<div class="station-lines">';
            station.lines.forEach(line => {
                const bgColor = line.color || getTypeColor(type);
                const displayName = line.ref || line.name || line.type;
                linesHtml += `
                    <span class="line-badge" style="background: ${bgColor}">
                        ${line.ref ? `<span class="line-ref">${line.ref}</span>` : ''}
                        ${line.name && line.name !== line.ref ? line.name : (line.type || '')}
                    </span>
                `;
            });
            linesHtml += '</div>';
        }

        return `
            <div class="station-item ${type}" data-idx="${idx}" data-lat="${station.lat}" data-lon="${station.lon}">
                <div class="station-name">${station.name}</div>
                <span class="station-type ${type}">${type}</span>
                <div class="station-distances">
                    <span>üìè ${linearDist.toFixed(0)}–º</span>
                    <span>üö∂ ${walkingDist.toFixed(0)}–º</span>
                    <span>‚è±Ô∏è ${walkingTime.toFixed(1)} –º–∏–Ω</span>
                </div>
                ${linesHtml}
            </div>
        `;
    }

    function addStationMarker(station) {
        const el = document.createElement('div');
        el.className = `station-marker ${station.type || 'station'}`;

        const marker = new mapboxgl.Marker(el)
            .setLngLat([station.lon, station.lat])
            .addTo(map);

        el.addEventListener('click', (e) => {
            e.stopPropagation();
            showStationPopup(station);
        });

        stationMarkers.push(marker);
    }

    function showStationPopup(station) {
        if (activePopup) {
            activePopup.remove();
        }

        let linesHtml = '';
        if (station.lines && station.lines.length > 0) {
            linesHtml = '<div class="popup-lines">';
            station.lines.forEach(line => {
                const bgColor = line.color || getTypeColor(station.type);
                linesHtml += `
                    <span class="line-badge" style="background: ${bgColor}">
                        ${line.ref || line.name}
                    </span>
                `;
            });
            linesHtml += '</div>';
        }

        const linearDist = station.linear_distance || station.distance || 0;
        const walkingDist = station.walking_distance || linearDist * 1.2;
        const walkingTime = station.walking_time || (walkingDist / 83.3);

        activePopup = new mapboxgl.Popup({ closeOnClick: false })
            .setLngLat([station.lon, station.lat])
            .setHTML(`
                <div class="popup-title">${station.name}</div>
                <div class="popup-type">${station.type}</div>
                <div class="popup-distance">
                    üìè ${linearDist.toFixed(0)}–º ¬∑ 
                    üö∂ ${walkingDist.toFixed(0)}–º ¬∑ 
                    ‚è±Ô∏è ${walkingTime.toFixed(1)} –º–∏–Ω
                </div>
                ${linesHtml}
            `)
            .addTo(map);
    }

    function getTypeColor(type) {
        const colors = {
            metro: '#d32f2f',
            train: '#0288d1',
            tram: '#f57c00',
            bus: '#388e3c',
            ferry: '#7b1fa2'
        };
        return colors[type] || '#666';
    }

    // ========== Initialize ==========
    document.addEventListener('DOMContentLoaded', initApp);
</script>
{{end}}
